{"version":3,"file":"js/2574.cf82bc8a.js","mappings":"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","sources":["webpack://opencdms-app/../../src/composables/filter.ts"],"sourcesContent":["/* eslint-disable max-statements */\n/* eslint-disable no-labels */\n\n// Utilities\nimport { getPropertyFromItem, propsFactory, wrapInArray } from '@/util'\nimport { computed, ref, unref, watchEffect } from 'vue'\n\n// Types\nimport type { PropType, Ref } from 'vue'\nimport type { MaybeRef } from '@/util'\nimport type { InternalItem } from './items'\n\n/**\n * - match without highlight\n * - single match (index), length already known\n * - single match (start, end)\n * - multiple matches (start, end), probably shouldn't overlap\n */\nexport type FilterMatch = boolean | number | [number, number] | [number, number][]\nexport type FilterFunction = (value: string, query: string, item?: any) => FilterMatch\nexport type FilterKeyFunctions = Record<string, FilterFunction>\nexport type FilterKeys = string | string[]\nexport type FilterMode = 'some' | 'every' | 'union' | 'intersection'\n\nexport interface FilterProps {\n  customFilter?: FilterFunction\n  customKeyFilter?: FilterKeyFunctions\n  filterKeys?: FilterKeys\n  filterMode?: FilterMode\n  noFilter?: boolean\n}\n\n// Composables\nexport const defaultFilter: FilterFunction = (value, query, item) => {\n  if (value == null || query == null) return -1\n\n  return value.toString().toLocaleLowerCase().indexOf(query.toString().toLocaleLowerCase())\n}\n\nexport const makeFilterProps = propsFactory({\n  customFilter: Function as PropType<FilterFunction>,\n  customKeyFilter: Object as PropType<FilterKeyFunctions>,\n  filterKeys: [Array, String] as PropType<FilterKeys>,\n  filterMode: {\n    type: String as PropType<FilterMode>,\n    default: 'intersection',\n  },\n  noFilter: Boolean,\n}, 'filter')\n\nexport function filterItems (\n  items: InternalItem[],\n  query: string,\n  options?: {\n    customKeyFilter?: FilterKeyFunctions\n    default?: FilterFunction\n    filterKeys?: FilterKeys\n    filterMode?: FilterMode\n    noFilter?: boolean\n  },\n) {\n  const array: { index: number, matches: Record<string, FilterMatch> }[] = []\n  // always ensure we fall back to a functioning filter\n  const filter = options?.default ?? defaultFilter\n  const keys = options?.filterKeys ? wrapInArray(options.filterKeys) : false\n  const customFiltersLength = Object.keys(options?.customKeyFilter ?? {}).length\n\n  if (!items?.length) return array\n\n  loop:\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i]\n    const customMatches: Record<string, FilterMatch> = {}\n    const defaultMatches: Record<string, FilterMatch> = {}\n    let match: FilterMatch = -1\n\n    if (query && !options?.noFilter) {\n      if (typeof item === 'object') {\n        const filterKeys = keys || Object.keys(item)\n\n        for (const key of filterKeys) {\n          const value = getPropertyFromItem(item as any, key, item)\n          const keyFilter = options?.customKeyFilter?.[key]\n\n          match = keyFilter\n            ? keyFilter(value, query, item)\n            : filter(value, query, item)\n\n          if (match !== -1 && match !== false) {\n            if (keyFilter) customMatches[key] = match\n            else defaultMatches[key] = match\n          } else if (options?.filterMode === 'every') {\n            continue loop\n          }\n        }\n      } else {\n        match = filter(item, query, item)\n        if (match !== -1 && match !== false) {\n          defaultMatches.title = match\n        }\n      }\n\n      const defaultMatchesLength = Object.keys(defaultMatches).length\n      const customMatchesLength = Object.keys(customMatches).length\n\n      if (!defaultMatchesLength && !customMatchesLength) continue\n\n      if (\n        options?.filterMode === 'union' &&\n        customMatchesLength !== customFiltersLength &&\n        !defaultMatchesLength\n      ) continue\n\n      if (\n        options?.filterMode === 'intersection' &&\n        (\n          customMatchesLength !== customFiltersLength ||\n          !defaultMatchesLength\n        )\n      ) continue\n    }\n\n    array.push({ index: i, matches: { ...defaultMatches, ...customMatches } })\n  }\n\n  return array\n}\n\nexport function useFilter <T extends InternalItem> (\n  props: FilterProps,\n  items: MaybeRef<T[]>,\n  query: Ref<string | undefined>,\n  options?: {\n    filterKeys?: MaybeRef<FilterKeys>\n  }\n) {\n  const strQuery = computed(() => (\n    typeof query?.value !== 'string' &&\n    typeof query?.value !== 'number'\n  ) ? '' : String(query.value))\n\n  const filteredItems: Ref<T[]> = ref([])\n  const filteredMatches: Ref<Map<unknown, Record<string, FilterMatch>>> = ref(new Map())\n\n  watchEffect(() => {\n    filteredItems.value = []\n    filteredMatches.value = new Map()\n\n    const transformedItems = unref(items)\n    const results = filterItems(\n      transformedItems,\n      strQuery.value,\n      {\n        customKeyFilter: props.customKeyFilter,\n        default: props.customFilter,\n        filterKeys: unref(options?.filterKeys) ?? props.filterKeys,\n        filterMode: props.filterMode,\n        noFilter: props.noFilter,\n      },\n    )\n\n    results.forEach(({ index, matches }) => {\n      const item = transformedItems[index]\n      filteredItems.value.push(item)\n      filteredMatches.value.set(item.value, matches)\n    })\n  })\n\n  function getMatches (item: T) {\n    return filteredMatches.value.get(item.value)\n  }\n\n  return { filteredItems, filteredMatches, getMatches }\n}\n"],"names":["defaultFilter","value","query","item","toString","toLocaleLowerCase","indexOf","makeFilterProps","propsFactory","customFilter","Function","customKeyFilter","Object","filterKeys","Array","String","filterMode","type","default","noFilter","Boolean","filterItems","items","options","array","filter","keys","wrapInArray","customFiltersLength","length","loop","i","customMatches","defaultMatches","match","key","getPropertyFromItem","keyFilter","title","defaultMatchesLength","customMatchesLength","push","index","matches","useFilter","props","strQuery","computed","filteredItems","ref","filteredMatches","Map","getMatches","get","watchEffect","transformedItems","unref","results","forEach","_ref","set"],"sourceRoot":""}
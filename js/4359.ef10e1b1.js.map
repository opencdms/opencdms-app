{"version":3,"file":"js/4359.ef10e1b1.js","mappings":"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","sources":["webpack://opencdms-app/./node_modules/geojson-validation/index.js","webpack://opencdms-app/./src/web-components/maps/feature-map.vue","webpack://opencdms-app/./src/web-components/maps/feature-map.vue?74ba"],"sourcesContent":["/**\n * geoJSON validation according to the GeoJSON spefication Version 1\n * @module geoJSONValidation\n * @class Main\n * @exports {GJV}\n */\n\nconst definitions = {}\n\n/**\n * Test an object to see if it is a function\n * @method isFunction\n * @param object {Object}\n * @return {Boolean}\n */\nfunction isFunction (object) {\n  return typeof (object) === 'function'\n}\n\n/**\n * A truthy test for objects\n * @method isObject\n * @param {Object}\n * @return {Boolean}\n */\nfunction isObject (object) {\n  return object === Object(object)\n}\n\n/**\n * Formats error messages, calls the callback\n * @method done\n * @private\n * @param trace {Boolean} Whether or not to return the trace\n * @param [message]\n * @return {Boolean} is the object valid or not?\n */\nfunction _done (trace, message) {\n  let valid = false\n\n  if (typeof message === 'string') {\n    message = [message]\n  } else if (Object.prototype.toString.call(message) === '[object Array]') {\n    if (message.length === 0) {\n      valid = true\n    }\n  } else {\n    valid = true\n  }\n\n  if (trace) {\n    return message\n  } else {\n    return valid\n  }\n}\n\n/**\n * calls a custom definition if one is avalible for the given type\n * @method _customDefinitions\n * @private\n * @param type {'String'} a GeoJSON object type\n * @param object {Object} the Object being tested\n * @return {Array} an array of errors\n */\nfunction _customDefinitions (type, object) {\n  let errors\n\n  if (isFunction(definitions[type])) {\n    try {\n      errors = definitions[type](object)\n    } catch (e) {\n      errors = ['Problem with custom definition for '+type+': '+e]\n    }\n    if (typeof result === 'string') {\n      errors = [errors]\n    }\n    if (Object.prototype.toString.call(errors) === '[object Array]') {\n      return errors\n    }\n  }\n  return []\n}\n\n/**\n * Define a custom validation function for one of GeoJSON objects\n * @method define\n * @param type {GeoJSON Type} the type\n * @param definition {Function} A validation function\n * @return {Boolean} Return true if the function was loaded corectly else false\n */\nexports.define = (type, definition) => {\n  if ((type in allTypes) && isFunction(definition)) {\n    // TODO: check to see if the type is valid\n    definitions[type] = definition\n    return true\n  } else {\n    return false\n  }\n}\n\n/**\n * Determines if an object is a position or not\n * @method isPosition\n * @param position {Array}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isPosition = (position, trace = false) => {\n  let errors = []\n\n  // It must be an array\n  if (Array.isArray(position)) {\n    // and the array must have more than one element\n    if (position.length <= 1) {\n      errors.push('Position must be at least two elements')\n    }\n\n    position.forEach((pos, index) => {\n      if (typeof pos !== 'number') {\n        errors.push('Position must only contain numbers. Item '+pos+' at index '+index+' is invalid.')\n      }\n    })\n  } else {\n    errors.push('Position must be an array')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('Position', position))\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a GeoJSON Object or not\n * @method isGeoJSONObject|valid\n * @param geoJSONObject {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isGeoJSONObject = exports.valid = (geoJSONObject, trace = false) => {\n  if (!isObject(geoJSONObject)) {\n    return _done(trace, ['must be a JSON Object'])\n  } else {\n    let errors = []\n    if ('type' in geoJSONObject) {\n      if (nonGeoTypes[geoJSONObject.type]) {\n        return nonGeoTypes[geoJSONObject.type](geoJSONObject, trace)\n      } else if (geoTypes[geoJSONObject.type]) {\n        return geoTypes[geoJSONObject.type](geoJSONObject, trace)\n      } else {\n        errors.push('type must be one of: \"Point\", \"MultiPoint\", \"LineString\", \"MultiLineString\", \"Polygon\", \"MultiPolygon\", \"GeometryCollection\", \"Feature\", or \"FeatureCollection\"')\n      }\n    } else {\n      errors.push('must have a member with the name \"type\"')\n    }\n\n    // run custom checks\n    errors = errors.concat(_customDefinitions('GeoJSONObject', geoJSONObject))\n    return _done(trace, errors)\n  }\n}\n\n/**\n * Determines if an object is a Geometry Object or not\n * @method isGeometryObject\n * @param geometryObject {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isGeometryObject = (geometryObject, trace = false) => {\n  if (!isObject(geometryObject)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n  if ('type' in geometryObject) {\n    if (geoTypes[geometryObject.type]) {\n      return geoTypes[geometryObject.type](geometryObject, trace)\n    } else {\n      errors.push('type must be one of: \"Point\", \"MultiPoint\", \"LineString\", \"MultiLineString\", \"Polygon\", \"MultiPolygon\" or \"GeometryCollection\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('GeometryObject', geometryObject))\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a Point or not\n * @method isPoint\n * @param point {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isPoint = (point, trace = false) => {\n  if (!isObject(point)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n  if ('bbox' in point) {\n    const t = exports.isBbox(point.bbox, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  }\n\n  if ('type' in point) {\n    if (point.type !== 'Point') {\n      errors.push('type must be \"Point\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  if ('coordinates' in point) {\n    const t = exports.isPosition(point.coordinates, true)\n    if (t.length) {\n\terrors = errors.concat(t)\n    }\n  } else {\n    errors.push('must have a member with the name \"coordinates\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('Point', point))\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an array can be interperted as coordinates for a MultiPoint\n * @method isMultiPointCoor\n * @param coordinates {Array}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isMultiPointCoor = (coordinates, trace = false) => {\n  let errors = []\n\n  if (Array.isArray(coordinates)) {\n    coordinates.forEach((val, index) => {\n      const t = exports.isPosition(val, true)\n      if (t.length) {\n        // modify the err msg from \"isPosition\" to note the element number\n        t[0] = 'at ' + index + ': '.concat(t[0])\n        // build a list of invalide positions\n        errors = errors.concat(t)\n      }\n    })\n  } else {\n    errors.push('coordinates must be an array')\n  }\n  return _done(trace, errors)\n}\n/**\n * Determines if an object is a MultiPoint or not\n * @method isMultiPoint\n * @param position {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isMultiPoint = (multiPoint, trace = false) => {\n  if (!isObject(multiPoint)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n  if ('bbox' in multiPoint) {\n    const t = exports.isBbox(multiPoint.bbox, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  }\n\n  if ('type' in multiPoint) {\n    if (multiPoint.type !== 'MultiPoint') {\n      errors.push('type must be \"MultiPoint\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  if ('coordinates' in multiPoint) {\n    const t = exports.isMultiPointCoor(multiPoint.coordinates, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  } else {\n    errors.push('must have a member with the name \"coordinates\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('MultiPoint', multiPoint))\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an array can be interperted as coordinates for a lineString\n * @method isLineStringCoor\n * @param coordinates {Array}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isLineStringCoor = (coordinates, trace = false) => {\n  let errors = []\n  if (Array.isArray(coordinates)) {\n    if (coordinates.length > 1) {\n      coordinates.forEach((val, index) => {\n        const t = exports.isPosition(val, true)\n        if (t.length) {\n          // modify the err msg from 'isPosition' to note the element number\n          t[0] = 'at ' + index + ': '.concat(t[0])\n          // build a list of invalide positions\n          errors = errors.concat(t)\n        }\n      })\n    } else {\n      errors.push('coordinates must have at least two elements')\n    }\n  } else {\n    errors.push('coordinates must be an array')\n  }\n\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a lineString or not\n * @method isLineString\n * @param lineString {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isLineString = (lineString, trace = false) => {\n  if (!isObject(lineString)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n  if ('bbox' in lineString) {\n    const t = exports.isBbox(lineString.bbox, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  }\n\n  if ('type' in lineString) {\n    if (lineString.type !== 'LineString') {\n      errors.push('type must be \"LineString\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  if ('coordinates' in lineString) {\n    const t = exports.isLineStringCoor(lineString.coordinates, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  } else {\n    errors.push('must have a member with the name \"coordinates\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('LineString', lineString))\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an array can be interperted as coordinates for a MultiLineString\n * @method isMultiLineStringCoor\n * @param coordinates {Array}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isMultiLineStringCoor = (coordinates, trace = false) => {\n    let errors = []\n    if (Array.isArray(coordinates)) {\n\tcoordinates.forEach((val, index) => {\n\t    const t = exports.isLineStringCoor(val, true)\n\t    if (t.length) {\n\t\t// modify the err msg from 'isPosition' to note the element number\n\t\tt[0] = 'at ' + index + ': '.concat(t[0])\n\t\t// build a list of invalide positions\n\t\terrors = errors.concat(t)\n\t    }\n\t})\n    } else {\n\terrors.push('coordinates must be an array')\n    }\n    return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a MultiLine String or not\n * @method isMultiLineString\n * @param multilineString {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isMultiLineString = (multilineString, trace = false) => {\n  if (!isObject(multilineString)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n  if ('bbox' in multilineString) {\n    const t = exports.isBbox(multilineString.bbox, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  }\n\n  if ('type' in multilineString) {\n    if (multilineString.type !== 'MultiLineString') {\n      errors.push('type must be \"MultiLineString\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  if ('coordinates' in multilineString) {\n    const t = exports.isMultiLineStringCoor(multilineString.coordinates, true)\n\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  } else {\n    errors.push('must have a member with the name \"coordinates\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('MultiPoint', multilineString))\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an array is a linear Ring String or not\n * @method isMultiLineString\n * @private\n * @param coordinates {Array}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nfunction _linearRingCoor (coordinates, trace) {\n  let errors = []\n  if (Array.isArray(coordinates)) {\n    // 4 or more positions\n    coordinates.forEach((val, index) => {\n      const t = exports.isPosition(val, true)\n      if (t.length) {\n\t// modify the err msg from 'isPosition' to note the element number\n\tt[0] = 'at ' + index + ': '.concat(t[0])\n\t// build a list of invalide positions\n\terrors = errors.concat(t)\n      }\n    })\n\n    // check the first and last positions to see if they are equivalent\n    // TODO: maybe better checking?\n    if (coordinates[0].toString() !== coordinates[coordinates.length - 1].toString()) {\n      errors.push('The first and last positions must be equivalent')\n    }\n\n    if (coordinates.length < 4) {\n      errors.push('coordinates must have at least four positions')\n    }\n  } else {\n    errors.push('coordinates must be an array')\n  }\n\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an array is valid Polygon Coordinates or not\n * @method _polygonCoor\n * @private\n * @param coordinates {Array}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isPolygonCoor = (coordinates, trace = false) => {\n  let errors = []\n  if (Array.isArray(coordinates)) {\n    coordinates.forEach((val, index) => {\n      const t = _linearRingCoor(val, true)\n\n      if (t.length) {\n        // modify the err msg from 'isPosition' to note the element number\n        t[0] = 'at ' + index + ': '.concat(t[0])\n        // build a list of invalid positions\n        errors = errors.concat(t)\n      }\n    })\n  } else {\n    errors.push('coordinates must be an array')\n  }\n\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a valid Polygon\n * @method isPolygon\n * @param polygon {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isPolygon = (polygon, trace = false) => {\n  if (!isObject(polygon)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n\n  if ('bbox' in polygon) {\n    const t = exports.isBbox(polygon.bbox, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  }\n\n  if ('type' in polygon) {\n    if (polygon.type !== 'Polygon') {\n      errors.push('type must be \"Polygon\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  if ('coordinates' in polygon) {\n    const t = exports.isPolygonCoor(polygon.coordinates, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  } else {\n    errors.push('must have a member with the name \"coordinates\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('Polygon', polygon))\n\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an array can be interperted as coordinates for a MultiPolygon\n * @method isMultiPolygonCoor\n * @param coordinates {Array}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isMultiPolygonCoor = (coordinates, trace = false) => {\n  let errors = []\n  if (Array.isArray(coordinates)) {\n    coordinates.forEach((val, index) => {\n      const t = exports.isPolygonCoor(val, true)\n      if (t.length) {\n        // modify the err msg from 'isPosition' to note the element number\n        t[0] = 'at ' + index + ': '.concat(t[0])\n        // build a list of invalide positions\n        errors = errors.concat(t)\n      }\n    })\n  } else {\n    errors.push('coordinates must be an array')\n  }\n\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a valid MultiPolygon\n * @method isMultiPolygon\n * @param multiPolygon {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isMultiPolygon = (multiPolygon, trace = false) => {\n  if (!isObject(multiPolygon)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n  if ('bbox' in multiPolygon) {\n    const t = exports.isBbox(multiPolygon.bbox, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  }\n\n  if ('type' in multiPolygon) {\n    if (multiPolygon.type !== 'MultiPolygon') {\n      errors.push('type must be \"MultiPolygon\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  if ('coordinates' in multiPolygon) {\n    const t = exports.isMultiPolygonCoor(multiPolygon.coordinates, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  } else {\n    errors.push('must have a member with the name \"coordinates\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('MultiPolygon', multiPolygon))\n\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a valid Geometry Collection\n * @method isGeometryCollection\n * @param geometryCollection {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isGeometryCollection = (geometryCollection, trace = false) => {\n  if (!isObject(geometryCollection)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n  if ('bbox' in geometryCollection) {\n    const t = exports.isBbox(geometryCollection.bbox, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  }\n\n  if ('type' in geometryCollection) {\n    if (geometryCollection.type !== 'GeometryCollection') {\n      errors.push('type must be \"GeometryCollection\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  if ('geometries' in geometryCollection) {\n    if (Array.isArray(geometryCollection.geometries)) {\n      geometryCollection.geometries.forEach((val, index) => {\n        const t = exports.isGeometryObject(val, true)\n        if (t.length) {\n          // modify the err msg from 'isPosition' to note the element number\n          t[0] = 'at ' + index + ': '.concat(t[0])\n          // build a list of invalide positions\n          errors = errors.concat(t)\n        }\n      })\n    } else {\n      errors.push('\"geometries\" must be an array')\n    }\n  } else {\n    errors.push('must have a member with the name \"geometries\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('GeometryCollection', geometryCollection))\n\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a valid Feature\n * @method isFeature\n * @param feature {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isFeature = (feature, trace = false) => {\n  if (!isObject(feature)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n  if ('bbox' in feature) {\n    const t = exports.isBbox(feature.bbox, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  }\n\n  if ('type' in feature) {\n    if (feature.type !== 'Feature') {\n      errors.push('type must be \"Feature\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  if (!('properties' in feature)) {\n    errors.push('must have a member with the name \"properties\"')\n  }\n\n  if ('geometry' in feature) {\n    if (feature.geometry !== null) {\n      const t = exports.isGeometryObject(feature.geometry, true)\n      if (t.length) {\n        errors = errors.concat(t)\n      }\n    }\n  } else {\n    errors.push('must have a member with the name \"geometry\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('Feature', feature))\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a valid Feature Collection\n * @method isFeatureCollection\n * @param featureCollection {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isFeatureCollection = (featureCollection, trace = false) => {\n  if (!isObject(featureCollection)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n  if ('bbox' in featureCollection) {\n    const t = exports.isBbox(featureCollection.bbox, true)\n    if (t.length) {\n      errors = t\n    }\n  }\n\n  if ('type' in featureCollection) {\n    if (featureCollection.type !== 'FeatureCollection') {\n      errors.push('type must be \"FeatureCollection\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  if ('features' in featureCollection) {\n    if (Array.isArray(featureCollection.features)) {\n      featureCollection.features.forEach((val, index) => {\n        const t = exports.isFeature(val, true)\n        if (t.length) {\n\n          // modify the err msg from 'isPosition' to note the element number\n          t[0] = 'at ' + index + ': '.concat(t[0])\n          // build a list of invalide positions\n          errors = errors.concat(t)\n        }\n      })\n    } else {\n      errors.push('\"Features\" must be an array')\n    }\n  } else {\n    errors.push('must have a member with the name \"Features\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('FeatureCollection', featureCollection))\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a valid Bounding Box\n * @method isBbox\n * @param bbox {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isBbox = (bbox, trace = false) => {\n  let errors = []\n  if (Array.isArray(bbox)) {\n    if (bbox.length % 2 !== 0) {\n      errors.push('bbox, must be a 2*n array')\n    }\n  } else {\n    errors.push('bbox must be an array')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('Bbox', bbox))\n  return _done(trace, errors)\n}\n\nconst nonGeoTypes = {\n  'Feature': exports.isFeature,\n  'FeatureCollection': exports.isFeatureCollection\n}\n\nconst geoTypes = {\n  'Point': exports.isPoint,\n  'MultiPoint': exports.isMultiPoint,\n  'LineString': exports.isLineString,\n  'MultiLineString': exports.isMultiLineString,\n  'Polygon': exports.isPolygon,\n  'MultiPolygon': exports.isMultiPolygon,\n  'GeometryCollection': exports.isGeometryCollection\n}\n\nconst allTypes = {\n  'Feature': exports.isFeature,\n  'FeatureCollection': exports.isFeatureCollection,\n  'Point': exports.isPoint,\n  'MultiPoint': exports.isMultiPoint,\n  'LineString': exports.isLineString,\n  'MultiLineString': exports.isMultiLineString,\n  'Polygon': exports.isPolygon,\n  'MultiPolygon': exports.isMultiPolygon,\n  'GeometryCollection': exports.isGeometryCollection,\n  'Bbox': exports.isBbox,\n  'Position': exports.isPosition,\n  'GeoJSON': exports.isGeoJSONObject,\n  'GeometryObject': exports.isGeometryObject\n}\n\nexports.allTypes = allTypes\n","<template>\n      <base-map @mapLoaded=\"onMapLoaded\" style=\"height: 100%;\" zoom=\"4\" :id=\"id\"/>\n</template>\n\n\n<script>\n// geojson validator\nimport * as gjv from 'geojson-validation';\n\n// Leaflet\nimport L from 'leaflet';\n\n// vue imports\nimport { defineComponent, ref, computed, watch } from 'vue';\nimport { onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted, onErrorCaptured} from 'vue';\n\n// vuetify imports\nimport { VCard, VCardTitle, VCardText, VCardItem } from 'vuetify/lib/components';\n\n// OpenCDMS imports\nimport BaseMap from \"@/web-components/maps/base-map.vue\"\n\nexport default defineComponent({\n  name: \"FeatureMap\",\n  props: {\n    geom: {\n      type: Object,\n      required: false\n    },\n    id: {\n      type: String,\n      default: \"map\"\n    }\n  },\n  components: {\n    VCard, VCardTitle, VCardItem, VCardText,\n    BaseMap\n  },\n  setup( props, context ){\n    const map = ref(null);\n    const markerLayer = ref(null);\n    const onMapLoaded = async (mapInstance) => {\n      console.log( props.id )\n      map.value = mapInstance;\n      if ( props.geom ){\n        // make sure the geometry is valid\n        if( gjv.isFeature(props.geom) ){\n          // now add to map\n          markerLayer.value = L.geoJSON(props.geom).addTo(map.value);\n          map.value.fitBounds(markerLayer.value.getBounds());\n          map.value.setZoom(6);\n          console.log(\"invalid geom\");\n        }\n      }else{\n        console.log(\"No geometry\");\n      }\n    };\n    watch( () => props.geom, (newValue) => {\n      if( markerLayer.value ){\n        markerLayer.value.remove();\n      }\n      markerLayer.value = L.geoJSON(newValue).addTo(map.value);\n      map.value.fitBounds(markerLayer.value.getBounds());\n      map.value.setZoom(6);\n    })\n    return {map, onMapLoaded};\n  }\n});\n\n</script>\n","import { render } from \"./feature-map.vue?vue&type=template&id=5595360f\"\nimport script from \"./feature-map.vue?vue&type=script&lang=js\"\nexport * from \"./feature-map.vue?vue&type=script&lang=js\"\n\nimport exportComponent from \"/home/runner/work/opencdms-app/opencdms-app/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__"],"names":["definitions","isFunction","object","isObject","Object","_done","trace","message","valid","prototype","toString","call","length","_customDefinitions","type","errors","e","result","_linearRingCoor","coordinates","Array","isArray","forEach","val","index","t","exports","isPosition","concat","push","define","definition","allTypes","position","pos","isGeoJSONObject","geoJSONObject","nonGeoTypes","geoTypes","isGeometryObject","geometryObject","isPoint","point","isBbox","bbox","isMultiPointCoor","isMultiPoint","multiPoint","isLineStringCoor","isLineString","lineString","isMultiLineStringCoor","isMultiLineString","multilineString","isPolygonCoor","isPolygon","polygon","isMultiPolygonCoor","isMultiPolygon","multiPolygon","isGeometryCollection","geometryCollection","geometries","isFeature","feature","geometry","isFeatureCollection","featureCollection","features","_createBlock","_component_base_map","onMapLoaded","_ctx","style","zoom","id","defineComponent","name","props","geom","required","String","default","components","VCard","VCardTitle","VCardItem","VCardText","BaseMap","setup","context","map","ref","markerLayer","async","console","log","value","mapInstance","gjv","L","addTo","fitBounds","getBounds","setZoom","watch","newValue","remove","__exports__","render"],"sourceRoot":""}
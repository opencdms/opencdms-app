(self["webpackChunkopencdms_app"]=self["webpackChunkopencdms_app"]||[]).push([[4359],{6254:function(t,e,o){o(7658);const n={};function i(t){return"function"===typeof t}function r(t){return t===Object(t)}function s(t,e){let o=!1;return"string"===typeof e?e=[e]:"[object Array]"===Object.prototype.toString.call(e)?0===e.length&&(o=!0):o=!0,t?e:o}function a(t,e){let o;if(i(n[t])){try{o=n[t](e)}catch(r){o=["Problem with custom definition for "+t+": "+r]}if("string"===typeof result&&(o=[o]),"[object Array]"===Object.prototype.toString.call(o))return o}return[]}function u(t,o){let n=[];return Array.isArray(t)?(t.forEach(((t,o)=>{const i=e.isPosition(t,!0);i.length&&(i[0]="at "+o+": ".concat(i[0]),n=n.concat(i))})),t[0].toString()!==t[t.length-1].toString()&&n.push("The first and last positions must be equivalent"),t.length<4&&n.push("coordinates must have at least four positions")):n.push("coordinates must be an array"),s(o,n)}e.define=(t,e)=>!(!(t in m)||!i(e))&&(n[t]=e,!0),e.isPosition=(t,e=!1)=>{let o=[];return Array.isArray(t)?(t.length<=1&&o.push("Position must be at least two elements"),t.forEach(((t,e)=>{"number"!==typeof t&&o.push("Position must only contain numbers. Item "+t+" at index "+e+" is invalid.")}))):o.push("Position must be an array"),o=o.concat(a("Position",t)),s(e,o)},e.isGeoJSONObject=e.valid=(t,e=!1)=>{if(r(t)){let o=[];if("type"in t){if(c[t.type])return c[t.type](t,e);if(l[t.type])return l[t.type](t,e);o.push('type must be one of: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "GeometryCollection", "Feature", or "FeatureCollection"')}else o.push('must have a member with the name "type"');return o=o.concat(a("GeoJSONObject",t)),s(e,o)}return s(e,["must be a JSON Object"])},e.isGeometryObject=(t,e=!1)=>{if(!r(t))return s(e,["must be a JSON Object"]);let o=[];if("type"in t){if(l[t.type])return l[t.type](t,e);o.push('type must be one of: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon" or "GeometryCollection"')}else o.push('must have a member with the name "type"');return o=o.concat(a("GeometryObject",t)),s(e,o)},e.isPoint=(t,o=!1)=>{if(!r(t))return s(o,["must be a JSON Object"]);let n=[];if("bbox"in t){const o=e.isBbox(t.bbox,!0);o.length&&(n=n.concat(o))}if("type"in t?"Point"!==t.type&&n.push('type must be "Point"'):n.push('must have a member with the name "type"'),"coordinates"in t){const o=e.isPosition(t.coordinates,!0);o.length&&(n=n.concat(o))}else n.push('must have a member with the name "coordinates"');return n=n.concat(a("Point",t)),s(o,n)},e.isMultiPointCoor=(t,o=!1)=>{let n=[];return Array.isArray(t)?t.forEach(((t,o)=>{const i=e.isPosition(t,!0);i.length&&(i[0]="at "+o+": ".concat(i[0]),n=n.concat(i))})):n.push("coordinates must be an array"),s(o,n)},e.isMultiPoint=(t,o=!1)=>{if(!r(t))return s(o,["must be a JSON Object"]);let n=[];if("bbox"in t){const o=e.isBbox(t.bbox,!0);o.length&&(n=n.concat(o))}if("type"in t?"MultiPoint"!==t.type&&n.push('type must be "MultiPoint"'):n.push('must have a member with the name "type"'),"coordinates"in t){const o=e.isMultiPointCoor(t.coordinates,!0);o.length&&(n=n.concat(o))}else n.push('must have a member with the name "coordinates"');return n=n.concat(a("MultiPoint",t)),s(o,n)},e.isLineStringCoor=(t,o=!1)=>{let n=[];return Array.isArray(t)?t.length>1?t.forEach(((t,o)=>{const i=e.isPosition(t,!0);i.length&&(i[0]="at "+o+": ".concat(i[0]),n=n.concat(i))})):n.push("coordinates must have at least two elements"):n.push("coordinates must be an array"),s(o,n)},e.isLineString=(t,o=!1)=>{if(!r(t))return s(o,["must be a JSON Object"]);let n=[];if("bbox"in t){const o=e.isBbox(t.bbox,!0);o.length&&(n=n.concat(o))}if("type"in t?"LineString"!==t.type&&n.push('type must be "LineString"'):n.push('must have a member with the name "type"'),"coordinates"in t){const o=e.isLineStringCoor(t.coordinates,!0);o.length&&(n=n.concat(o))}else n.push('must have a member with the name "coordinates"');return n=n.concat(a("LineString",t)),s(o,n)},e.isMultiLineStringCoor=(t,o=!1)=>{let n=[];return Array.isArray(t)?t.forEach(((t,o)=>{const i=e.isLineStringCoor(t,!0);i.length&&(i[0]="at "+o+": ".concat(i[0]),n=n.concat(i))})):n.push("coordinates must be an array"),s(o,n)},e.isMultiLineString=(t,o=!1)=>{if(!r(t))return s(o,["must be a JSON Object"]);let n=[];if("bbox"in t){const o=e.isBbox(t.bbox,!0);o.length&&(n=n.concat(o))}if("type"in t?"MultiLineString"!==t.type&&n.push('type must be "MultiLineString"'):n.push('must have a member with the name "type"'),"coordinates"in t){const o=e.isMultiLineStringCoor(t.coordinates,!0);o.length&&(n=n.concat(o))}else n.push('must have a member with the name "coordinates"');return n=n.concat(a("MultiPoint",t)),s(o,n)},e.isPolygonCoor=(t,e=!1)=>{let o=[];return Array.isArray(t)?t.forEach(((t,e)=>{const n=u(t,!0);n.length&&(n[0]="at "+e+": ".concat(n[0]),o=o.concat(n))})):o.push("coordinates must be an array"),s(e,o)},e.isPolygon=(t,o=!1)=>{if(!r(t))return s(o,["must be a JSON Object"]);let n=[];if("bbox"in t){const o=e.isBbox(t.bbox,!0);o.length&&(n=n.concat(o))}if("type"in t?"Polygon"!==t.type&&n.push('type must be "Polygon"'):n.push('must have a member with the name "type"'),"coordinates"in t){const o=e.isPolygonCoor(t.coordinates,!0);o.length&&(n=n.concat(o))}else n.push('must have a member with the name "coordinates"');return n=n.concat(a("Polygon",t)),s(o,n)},e.isMultiPolygonCoor=(t,o=!1)=>{let n=[];return Array.isArray(t)?t.forEach(((t,o)=>{const i=e.isPolygonCoor(t,!0);i.length&&(i[0]="at "+o+": ".concat(i[0]),n=n.concat(i))})):n.push("coordinates must be an array"),s(o,n)},e.isMultiPolygon=(t,o=!1)=>{if(!r(t))return s(o,["must be a JSON Object"]);let n=[];if("bbox"in t){const o=e.isBbox(t.bbox,!0);o.length&&(n=n.concat(o))}if("type"in t?"MultiPolygon"!==t.type&&n.push('type must be "MultiPolygon"'):n.push('must have a member with the name "type"'),"coordinates"in t){const o=e.isMultiPolygonCoor(t.coordinates,!0);o.length&&(n=n.concat(o))}else n.push('must have a member with the name "coordinates"');return n=n.concat(a("MultiPolygon",t)),s(o,n)},e.isGeometryCollection=(t,o=!1)=>{if(!r(t))return s(o,["must be a JSON Object"]);let n=[];if("bbox"in t){const o=e.isBbox(t.bbox,!0);o.length&&(n=n.concat(o))}return"type"in t?"GeometryCollection"!==t.type&&n.push('type must be "GeometryCollection"'):n.push('must have a member with the name "type"'),"geometries"in t?Array.isArray(t.geometries)?t.geometries.forEach(((t,o)=>{const i=e.isGeometryObject(t,!0);i.length&&(i[0]="at "+o+": ".concat(i[0]),n=n.concat(i))})):n.push('"geometries" must be an array'):n.push('must have a member with the name "geometries"'),n=n.concat(a("GeometryCollection",t)),s(o,n)},e.isFeature=(t,o=!1)=>{if(!r(t))return s(o,["must be a JSON Object"]);let n=[];if("bbox"in t){const o=e.isBbox(t.bbox,!0);o.length&&(n=n.concat(o))}if("type"in t?"Feature"!==t.type&&n.push('type must be "Feature"'):n.push('must have a member with the name "type"'),"properties"in t||n.push('must have a member with the name "properties"'),"geometry"in t){if(null!==t.geometry){const o=e.isGeometryObject(t.geometry,!0);o.length&&(n=n.concat(o))}}else n.push('must have a member with the name "geometry"');return n=n.concat(a("Feature",t)),s(o,n)},e.isFeatureCollection=(t,o=!1)=>{if(!r(t))return s(o,["must be a JSON Object"]);let n=[];if("bbox"in t){const o=e.isBbox(t.bbox,!0);o.length&&(n=o)}return"type"in t?"FeatureCollection"!==t.type&&n.push('type must be "FeatureCollection"'):n.push('must have a member with the name "type"'),"features"in t?Array.isArray(t.features)?t.features.forEach(((t,o)=>{const i=e.isFeature(t,!0);i.length&&(i[0]="at "+o+": ".concat(i[0]),n=n.concat(i))})):n.push('"Features" must be an array'):n.push('must have a member with the name "Features"'),n=n.concat(a("FeatureCollection",t)),s(o,n)},e.isBbox=(t,e=!1)=>{let o=[];return Array.isArray(t)?t.length%2!==0&&o.push("bbox, must be a 2*n array"):o.push("bbox must be an array"),o=o.concat(a("Bbox",t)),s(e,o)};const c={Feature:e.isFeature,FeatureCollection:e.isFeatureCollection},l={Point:e.isPoint,MultiPoint:e.isMultiPoint,LineString:e.isLineString,MultiLineString:e.isMultiLineString,Polygon:e.isPolygon,MultiPolygon:e.isMultiPolygon,GeometryCollection:e.isGeometryCollection},m={Feature:e.isFeature,FeatureCollection:e.isFeatureCollection,Point:e.isPoint,MultiPoint:e.isMultiPoint,LineString:e.isLineString,MultiLineString:e.isMultiLineString,Polygon:e.isPolygon,MultiPolygon:e.isMultiPolygon,GeometryCollection:e.isGeometryCollection,Bbox:e.isBbox,Position:e.isPosition,GeoJSON:e.isGeoJSONObject,GeometryObject:e.isGeometryObject};e.allTypes=m},4359:function(t,e,o){"use strict";o.d(e,{Z:function(){return f}});var n=o(3396);function i(t,e,o,i,r,s){const a=(0,n.up)("base-map");return(0,n.wg)(),(0,n.j4)(a,{onMapLoaded:t.onMapLoaded,style:{height:"100%"},zoom:"4",id:t.id},null,8,["onMapLoaded","id"])}var r=o(6254),s=o(3153),a=o.n(s),u=o(4870),c=o(3238),l=o(6572),m=o(1209),h=o(1888),b=o(2257),y=(0,n.aZ)({name:"FeatureMap",props:{geom:{type:Object,required:!1},id:{type:String,default:"map"}},components:{VCard:c._,VCardTitle:l.E,VCardItem:m._,VCardText:h.Z,BaseMap:b.Z},setup(t,e){const o=(0,u.iH)(null),i=(0,u.iH)(null),s=async e=>{console.log(t.id),o.value=e,t.geom?r.isFeature(t.geom)&&(i.value=a().geoJSON(t.geom).addTo(o.value),o.value.fitBounds(i.value.getBounds()),o.value.setZoom(6),console.log("invalid geom")):console.log("No geometry")};return(0,n.YP)((()=>t.geom),(t=>{i.value&&i.value.remove(),i.value=a().geoJSON(t).addTo(o.value),o.value.fitBounds(i.value.getBounds()),o.value.setZoom(6)})),{map:o,onMapLoaded:s}}}),p=o(89);const g=(0,p.Z)(y,[["render",i]]);var f=g}}]);
//# sourceMappingURL=4359.ef10e1b1.js.map